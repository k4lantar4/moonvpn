---
description: 
globs: 
alwaysApply: false
---
# MoonVPN Telegram Bot Architecture

This rule outlines the architecture and organization of the Telegram bot components in the MoonVPN project.

## 1. Bot Structure Overview

The Telegram bot follows a modular structure with clear separation of concerns:

- [bot/main.py](mdc:bot/main.py): Entry point that initializes the bot and registers all components
- [bot/commands/](mdc:bot/commands): Command handlers for user interactions
- [bot/callbacks/](mdc:bot/callbacks): Callback query handlers for inline buttons
- [bot/buttons/](mdc:bot/buttons): InlineKeyboardMarkup definitions
- [bot/keyboards/](mdc:bot/keyboards): ReplyKeyboardMarkup definitions
- [bot/middlewares/](mdc:bot/middlewares): Request middleware (auth, throttling)
- [bot/notifications/](mdc:bot/notifications): Notification dispatching system

## 2. Command Implementation

When implementing new commands:

1. Create a file in [bot/commands/](mdc:bot/commands) named after the command
2. Define handler functions for the command
3. Create a registration function (e.g., `register_command_name`)
4. Update [bot/commands/\_\_init\_\_.py](mdc:bot/commands/__init__.py) to export the registration function
5. Register the command in [bot/main.py](mdc:bot/main.py)

Example command structure:
```python
# Function to handle the command
async def command_handler(message: types.Message):
    # ...implementation

# Function to register with dispatcher
def register_command(dp: Dispatcher, session_maker: sessionmaker):
    dp.message.register(command_handler, Command("command_name"))
```

## 3. Callback Pattern

For handling inline button callbacks:

1. Define callback data constants in the respective button file
2. Create handler functions in the corresponding callbacks file
3. Register callbacks using the pattern in [bot/callbacks/\_\_init\_\_.py](mdc:bot/callbacks/__init__.py)

## 4. State Management

For multi-step interactions:

1. Define states using `StatesGroup` and `State` classes
2. Use `state.set_state()` to set the current state
3. Register message handlers with state filters
4. Clear state when the interaction is complete

Example:
```python
class MyStates(StatesGroup):
    waiting_for_input = State()

# Setting state
await state.set_state(MyStates.waiting_for_input)

# Registering handler for state
router.message.register(handle_input, MyStates.waiting_for_input)

# Clearing state
await state.clear()
```

## 5. Session Management

Database sessions must be:

1. Created when needed
2. Used within a try-finally block
3. Always closed in the finally block to prevent leaks

By following these patterns, we maintain a consistent and maintainable bot structure.
